#!/bin/zsh

###########################
## Defining Chess Pieces ##
###########################

#shell doesnt have classes,
#so we need to use builtins.

#Format: <x><y><type><team>
#piece types:
#p - pawn
#r - rook
#n - knight
#b - bishop
#q - queen
#k - king

#piece teams:
#w - white
#b - black

initBoard=(
    11rw 21nw 31bw 41qw 51kw 61bw 71nw 81rw 
    12pw 22pw 32pw 42pw 52pw 62pw 72pw 82pw
    17pb 27pb 37pb 47pb 57pb 67pb 77pb 87pb
    18rb 28nb 38bb 48qb 58kb 68bb 78nb 88rb 
)

##############################
## End of piece definitions ##
##############################

#############
## Parsing ##
#############

#Functions do not have contingencies for incorrect args

function getPiecePos {
    local piece=$1
    echo ${piece:0:2}
}
function getPieceId {
    local piece=$1
    echo ${piece:2:2}
}
function getPieceType {
    local piece=$1
    echo ${piece:2:1}
}
function getPieceTeam {
    local piece=$1
    echo ${piece:3:1}
}
function oppositeTeam {
    local team=$1
    case $team in
      "w") echo "b" ;;
      "b") echo "w" ;;
      *) echo $team ;;
    esac
}

function searchPos {
    local pos=$1
    shift
    local board=("$@")
    for piece in $board
        if [[ $(getPiecePos $piece) == $pos ]]; then
            echo $piece
            return
        fi
    echo "empty"
}

function showPiece {
    local piece=$1
    case $(getPieceId $piece) in
      "pw")
          echo ♟
          ;;
      "rw")
          echo ♜
          ;;
      "nw")
          echo ♞
          ;;
      "bw")
          echo ♝
          ;;
      "qw")
          echo ♛
          ;;
      "kw")
          echo ♚
          ;;
      "pb")
          echo ♙
          ;;
      "rb")
          echo ♖
          ;;
      "nb")
          echo ♘
          ;;
      "bb")
          echo ♗
          ;;
      "qb")
          echo ♕
          ;;
      "kb")
          echo ♔
          ;;
      *)
          echo .
          ;;
    esac
}
function showBoard {
    local board=("$@")
    for y in {8..1}; do
        for x in {1..8}; do
            piece=$(searchPos "$x$y" $board)
            printf "%s " $(showPiece $piece)
        done
        echo
    done
}

#################
## End parsing ##
#################

###########
## Moves ##
###########

moves=()
function inBounds {
    local pos=$1
    [[ $pos -le 8 && $pos -ge 1 ]]
}
#TODO: check is position occupied
# function cleanup {
#   local new_moves=()
#   for move in $moves; do
#     if inBounds $move; then
#       new_moves+=$move
#     fi
#   done
#   moves=("${new_moves[@]}")
# }

#Does not include castling or en passant
function possibleMoves {
    local piece=$1
    local type=$(getPieceType $piece)
    local team=$(getPieceTeam $piece)

    local pos=$(getPiecePos $piece)
    local x=${pos:0:1}
    local y=${pos:1:1}

    shift
    local board=("$@")

    case $type in
      "p")
        #pawn moves
        case $team in
          "w")
            taking=()
            if [[ $(getPieceTeam $(searchPos "$((x+1))$((y+1))" $board)) == $(oppositeTeam $team) ]]; then
                taking+=("$((x+1))$((y+1))")
            fi
            if [[ $(getPieceTeam $(searchPos "$((x-1))$((y+1))" $board)) == $(oppositeTeam $team) ]]; then
                taking+=("$((x-1))$((y+1))")
            fi
            moves=("${taking[@]}" "$x$((y+1))" "$x$((y+2))")
            ;;
          "b")
            taking=()
            if [[ $(getPieceTeam $(searchPos "$((x-1))$((y-1))" $board)) == $(oppositeTeam $team) ]]; then
                taking+=("$((x-1))$((y-1))")
            fi
            if [[ $(getPieceTeam $(searchPos "$((x+1))$((y-1))" $board)) == $(oppositeTeam $team) ]]; then
                taking+=("$((x+1))$((y-1))")
            fi
            moves=("${taking[@]}" "$x$((y-1))" "$x$((y-2))")
            ;;
          *)
            echo "ERROR: unknown team"
            ;;
        esac
        ;;
      "r")
        #rook moves
        for i in {1..7}; do
          change=$((x+i))
          if inBounds $change; then
            moves+=("$change$y")
          fi
          change=$((x-i))
          if inBounds $change; then
            moves+=("$change$y")
          fi
          change=$((y+i))
          if inBounds $change; then
            moves+=("$x$change")
          fi
          change=$((y-i))
          if inBounds $change; then
            moves+=("$x$change")
          fi
        done
        ;;
      "n")
        #knight moves
        moves=()
        ;;
      "b")
        #bishop moves
        for i in {1..7}; do
          changex=$((x+i))
          if inBounds $changex; then
            changey=$((y+i))
            if inBounds $changey; then
              moves+=("$changex$changey")
            fi
            changey=$((y-i))
            if inBounds $changey; then
              moves+=("$changex$changey")
            fi
          fi
          changex=$((x-i))
          if inBounds $changex; then
            changey=$((y+i))
            if inBounds $changey; then
              moves+=("$changex$changey")
            fi
            changey=$((y-i))
            if inBounds $changey; then
              moves+=("$changex$changey")
            fi
          fi
        done
        ;;
      "q")
        #queen moves
        moves=()
        ;;
      "k")
        #king moves
        moves=()
        ;;
      *) 
        echo "ERROR: not a piece"
        ;;
    esac
}

possibleMoves "33bw" $initBoard
showBoard $initBoard
echo "Moves: ${moves[@]}"

###############
## End Moves ##
###############
